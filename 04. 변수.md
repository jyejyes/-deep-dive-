# 변수
메모리 주소에 직접 접근하는 것은 매우 위험하기 때문에 자바스크립트는 주소 직접접근을 허용하지 않는다.

✔️ 변수는 하나의 값을 저장하기 위해 확보한 메모리 공간 자체 또는 그 메모리 공간을 식별하기 위해 붙인 이름.  
✔️ 값의 위치를 가리키는 상징적 이름

# 식별자
코드는 컴퓨터에게 내리는 명령이지만 개발자를 위한 문서이다. 고로 개발자의 의도를 명확히 나타내는 변수명은 매우 중요하다.
이러한 식별자는 값이 저장되어 있는 메모리주소와 매핑관계이고 이 매핑정보도 메모리에 저장된다.

✔️ 변수 이름을 식별자라고 한다.   
식별자는 값이 아니라 메모리 주소를 기억하고 있다.

# 변수 선언
1. 값을 저장하기 위한 메모리 값을 확보.  
2. 변수 이름과 확보한 메모리 공간의 주소를 연결.  
### 변수 선언을 위한 var 키워드
```js
var score; //변수를 선언한 상태. 변수 이름을 등록하고 메모리 공간을 확보한다. 할당은 아직 하지 않았다. 
```
### 그렇다면, 확보된 메모리 공간은 비어있을까?
답은 ❌ , 확보된 메모리 공간에는 자바스크립트엔진 에 의해 undefined (원시타입 값)가 암묵적으로 할당되어 초기화된다.

즉, 자바스크립트 엔진은 변수 선언을 2단계에 걸쳐 수행한다.
1. 선언단계 : 변수 이름을 등록하여 자스엔진에 변수 존재를 알린다.
2. 초기화단계 : 값을 저장하기 위한 메모리 공간을 확보하고 undefined 를 할당하여 초기화한다.
이 때 초기화란, 변수가 생성되고 최초로 값을 할당하는 것.
### 초기화를 안하면?
이전에 사용했던 값이 남아 있을 수도 있음 -> 이것을 쓰레기 값이라고 부름.
그렇기에 자동으로 초기화를 시켜주는 var 키워드는 이러한 위험으로부터 안전하다.

### 변수 이름은 어디에 등록되나?
실행컨텍스트에 등록된다. 실행컨텍스트는 자스엔진이 코드를 실행하기 위해 필요한 환경을 제공하고 관리하는 영역이다.

# 호이스팅
```js
console.log(score); //undefined
var score;
```
자스 코드는 인터프리터 방식이기 때문에 코드를 순차적으로 읽어나간다. 
### 그렇다면 console 코드에서는 에러가 나야하는데 왜 에러가 나지 않을까?
함수의 선언은 런타임(코드 실행시점) 이전에 일어난다.   
소스를 실행하기 전 소스 실행 준비를 하는데 이 때 변수 선언을 포함한 모든 선언문을 소스코드에서 먼저 실행한다.(실행컨텍스트에 가져다두는것임)

이처럼, 마치 변수 선언문이 코드의 최상단으로 끌어올려진 것 처럼 보이는 현상을 호이스팅 이라고 한다.   
var 뿐 아니라 let, const, function, class 키워드 모두 호이스팅 된다.

# 값 할당
위의 선언과 다르게 할당은 소스코드가 순차적으로 실행되는 시간인 런타임에 동작한다.
```js
console.log(score);//undefined
var score=80;
console.log(score);//80
```
그렇기 때문에 선언과 할당을 한 번에 해도 실질적으로는 두 번의 선언, 할당 과정으로 나누어 실행된다.
